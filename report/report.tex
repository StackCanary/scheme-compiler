\documentclass{article}

\title{SH Project - A Scheme Compiler}
\date{14/01/2018}
\author{150008859}

\setlength{\parskip}{1em}
\setlength{\parindent}{0em}

\usepackage{listings}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{mathtools}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage{booktabs}

\begin{document}
\maketitle
\newpage

\section{Introduction}

The aim of this SH Project was to implement a compiler for a subset of Scheme detailed in the paper ``An incremental approach to Compiler Construction'', in which the author briefly describes its components across 24 sections. The compiler is written in Scheme coupled with a runtime in C.

Originally, the paper targets x86, but my project targets llvm IR instead. This allows me take a more modern approach as the paper is dated from 2006, to take advantage of many of the features that are bundled with llvm including its optimiser and it's ability to compile into many other architectures. 

\section{Project Layout}

The project is organised across many files.

\begin{verbatim}
 - scheme.scm       - The Scheme compiler.
 - runtime.c        - The complimentary runtime.
 - run.scm          - Reading file contents and running compiler.
 - test_driver.scm  - The testing framework.
 - Makefile         - A Makefile to drive compilation and tests. 
\end{verbatim}

% Talk about the runtime, the scheme_entry function and the emition of llvm and linking the object files


\section{Test Framework}

Due to the incremental nature of the project, the first task was to construct a test framework. This involved implement a procedure ``test'' which accepts a symbolic expression, compiles the s-expression into an executable binary and compares the result produced by the binary with the expected answer.

This allowed implementing a feature and immediately being able to verify the computation.

% Explain how it works, e.g. makefile and new directory.



\section{Immediate Values}

This section discusses the task of implementing immediate values which constitute of integers, characters, booleans and the empty list. It also gives an insight at the code emitted by the compiler. During the compilation process, immediates are packed into a ``value and tag form'' and returned.

Table~\ref{tab:immediates} shows the masks, tags and sizes of the packed immediates. For example, the value 42 is shifted left twice to produce the packed value 168. 

\begin{table}[ht]
  \centering
\begin{tabular}{ l c c c }
  \toprule
  Type & Mask & Tag & Size \\ \hline
  \midrule
  Integer & 0x03 & 0x00 & 30 bits  \\
  Character & 0xFF & 0x0F & 24 bits  \\
  Boolean & 0x7F & 0x1F & 1 bit \\
  Empty List & 0xFF & 0x2F & 0 bits \\
  \bottomrule
\end{tabular}
\caption{Masks, tags and sizes of immediate values.} \label{tab:immediates}
\end{table}

The following example demonstrates how the immediate value ``42'' is compiled. 

\begin{verbatim}
>42

 define i64 @scheme_entry()   /* Header 
 {                            
   entry:
   %tmp = alloca i64              ..  */

   store i64 168, i64* %tmp   /* Body */ 

   %ret = load i64, i64* %tmp /* Footer
   ret i64 %ret                   
 }                                ..  */
\end{verbatim}

As there are no registers or an operand stack in llvm, a variable representing a memory location named ``tmp'' is designated as the return value holder similar to how the ``eax'' register holds the return address in the cdecl calling convention. The variable is allocated in the header. At the end of the program, the value stored in tmp is returned. In the runtime, the ``scheme\_entry'' function is called and displays the value returned. 

To supplement the immediate values, the runtime was extended to display the immediate value returned by the program. 

\section{Primitives}

The compiler was then extended by adding unary primitives. Unary primitives are procedures which are natively defined in the environment and accept a single argument. Arguments are emitted first and the result stored in temporary variables. 

\begin{verbatim}
>(add1 42)

 define i64 @scheme_entry()     /* Header
 {
   entry:
   %tmp = alloca i64                    .. */
   store i64 168, i64* %tmp     /* Emit 42 */ 
   %var10 = load i64, i64* %tmp 
   %var11 = add i64 %var10, 4   /* Add   1 */
   store i64 %var11, i64* %tmp  
   %ret = load i64, i64* %tmp   /* Footer 
   ret i64 %ret                         .. */
 }
\end{verbatim}

These unary primitives can be combined to form some semblance of a program.

\begin{verbatim}
>(add1 (sub1 42))

 define i64 @scheme_entry()
 {
   entry: 
   %tmp = alloca i64
   store i64 168, i64* %tmp
   %var12 = load i64, i64* %tmp
   %var13 = sub i64 %var12, 4
   store i64 %var13, i64* %tmp
   %var10 = load i64, i64* %tmp
   %var11 = add i64 %var10, 4
   store i64 %var11, i64* %tmp
   %ret = load i64, i64* %tmp
   ret i64 %ret
 }
\end{verbatim}


\section{Let and the Local Variables}

The let primitive allows us to bind an expression to a symbol in a body. 

\begin{verbatim}

(let ((var1 exp1)      /* Bindings
      (var2 exp2) ..)     ..       */
         body ..)      /* Body     */   

\end{verbatim}

A simple example shows the interal workings of the let primitive.

\begin{verbatim}

>(let ((x 1) (y 2)) (add x y)) 

define i64 @scheme_entry()       /* Header
{                    
entry: 
%tmp = alloca i64                                 .. */

// Bindings       

store i64 4, i64* %tmp           /* Emit 1 into        
%var10 = load i64, i64* %tmp     symbol x (var10) .. */

store i64 8, i64* %tmp           /* Emit 2 into           
%var11 = load i64, i64* %tmp     symbol y (var11) .. */

// Body

store i64 %var11, i64* %tmp      /* Load x      
%var12 = load i64, i64* %tmp                      .. */

store i64 %var10, i64* %tmp      /* Load y
%var13 = load i64, i64* %tmp                      .. */

%var14 = add i64 %var13, %var12  /* Addition
store i64 %var14, i64* %tmp                       .. */

%ret = load i64, i64* %tmp       /* Footer
ret i64 %ret                                  .. */
}

\end{verbatim}

The compiler was extended by an environment, a dictionary which maps symbols to llvm variable names ([x var10], [y, var11], ..). Ordinarily, if we had used x86, we would have had to construct stack frames, manage the stack pointer and map symbols to offsets from current frame pointer. Local variables in llvm are represented by llvm variables. Binding a variable emits the right hand side expression and stores the value into a variable.

\begin{verbatim}
 store i64 4, i64* %tmp        /* Emit 1 */
 %var10 = load i64, i64* %tmp  /* Load into symbol x (var10) */  
\end{verbatim}

 In the body of the expression, the environment is available. When a symbol is referenced, it's value is emitted.
 
\begin{verbatim}
store i64 %var11, i64* %tmp     /* Emit x (var11)     
%var12 = load i64, i64* %tmp                   .. */
\end{verbatim}

Slightly more complex programs can be constructed in which we can store the result of an expression into symbols. 

\section{Let*}

The let* primitive is identical to the let primitive, except the variable bindings can be referenced in consecutive bindings. The syntax is identical.

The following example illustrates a use of the let* primitive. 

\begin{verbatim}

(let* ((var1 exp1)      /* Bindings
       (var2 var1)     
       (var3 var2))      ..         */
          body ..)      /* Body     */   

\end{verbatim}

The let* primitive can be code transformed into nested let primitives and are implemented as such. The following example shows the transformed version.

\begin{verbatim}

(let ((var1 exp1))
 (let ((var2 var1))
  (let ((var3 var2))
   body ..))) 
 
\end{verbatim}

\section{Begin}

Multiple s-expressions can be chained sequentially through use of the Begin primitive. The return value of the final expression is returned. 

\begin{verbatim}

(begin exp1 exp2 ...) 

\end{verbatim}

\section{Conditionals}

The conditional primitives include if and cond.

\begin{verbatim}

(if condition consequent alternative)

\end{verbatim}

A short example shows the implementation.

\begingroup
    \fontsize{8pt}{5pt}\selectfont
\begin{verbatim}

// A program to return the lower of x and y. 

(let ([x 3] 
      [y 5])
      (if (< x y) x y))

define i64 @scheme_entry()
{
 entry: 
 %tmp = alloca i64
 store i64 12, i64* %tmp
 %var10 = load i64, i64* %tmp
 store i64 20, i64* %tmp
 %var11 = load i64, i64* %tmp
 store i64 %var11, i64* %tmp
 %var17 = load i64, i64* %tmp
 store i64 %var10, i64* %tmp
 %var18 = load i64, i64* %tmp
 %var19 = icmp slt i64 %var18, %var17
 %var20 = zext i1 %var19 to i64
 %var21 = shl i64 %var20, 7
 %var22 = or i64 %var21, 31
 store i64 %var22, i64* %tmp
 %var15 = load i64, i64* %tmp
 %var16 = icmp eq i64 %var15, 159
 br i1 %var16, label %lab12, label %lab13 
 lab12:
 store i64 %var10, i64* %tmp
 br label %lab14 
 lab13:
 store i64 %var11, i64* %tmp
 br label %lab14 
 lab14:
 %ret = load i64, i64* %tmp
 ret i64 %ret
}
\end{verbatim}
\endgroup

\section{Lambdas}

Now that our program contains many useful primitives, the next task is to implement lambdas. In order to implement lambdas, I visited several external resources. One, which was a blog on the topic of Closure Conversion \cite{closure-conversion}.

Syntactically, a lambda is expressed as the following and describes anonymous functions. 

\begin{verbatim}
(lambda (formal args) body)
\end{verbatim}

\begin{table}[ht]
  \centering
\begin{tabular}{ l l }
  \toprule
  Primcall & Description \\ \hline
  \midrule
  (lambda? (formal args) body) & Constructs a lambda \\
  \bottomrule
\end{tabular}
\caption{Primitives related to lambdas.} \label{tab:lambdas}
\end{table}



However, a lambda does not simply compile into a function pointer. This is because Scheme has lexical scoping. It is possible for an expression in the body of a lambda to contain a free variable. A free variable is one which is not defined in the formal arguments of the lambda expression. 

\begin{verbatim}

The variable x is free in the body of the second lambda expression. 

(lambda (x) 
 (lambda (y) 
  (add x y)))

\end{verbatim}

Instead, a lambda compiles into a ``closure'' which is a datastructure that contains a pointer to a function and the values of its free variables.



\subsection{Code Transformation}

In order to accomplish this, the lambda expression is transformed into an intermediate forms. Table~\ref{tab:lambda_intermediate} shows the intermediate forms. 

\begin{table}[ht]
  \centering
\begin{tabular}{ l l }
  \toprule
  Primcall & Description \\ \hline
  \midrule
  (closure lvar fvar ... ) & Emits a pointer to a Closure Object on the heap.  \\
  (funcall expr args) & Calls the expr with the given args.  \\
  (labels ...) & ... \\
  (code lvar fvar expr ... ) & ... \\
  \bottomrule
\end{tabular}
\caption{Primitives related to lambda intermediate forms.} \label{tab:lambda_intermediate}
\end{table}

\subsection{Code Emitted}




\section{Datastructures and the Heap}

Pairs, Vectors, Closures and Strings are datastructures that cannot be represented by a single fixed width number. Hence, the runtime was extended by adding a heap. A contigious region of memory is allocated to store runtime objects that cannot be represented by an immediate.

The objects are constructed on the heap and a pointer to them is emitted. By aligning the allocated objects to a multiple of 8, the last 3 bits of a pointer can be used to store a tag, these can be found in Table~\ref{tab:datastructures}.

\begin{table}[ht]
  \centering
\begin{tabular}{ l c c }
  \toprule
  Type & Mask & Tag  \\ \hline
  \midrule
  Pairs  & 0x07 & 0x01 \\
  Closures & 0x07 & 0x02 \\
  Vectors & 0x07 & 0x05 \\
  Strings & 0x07 & 0x06 \\
  \bottomrule
\end{tabular}
\caption{Masks and Tags of datastructures.} \label{tab:datastructures}
\end{table}

\subsection{Pairs}

The primitives required for the construction of pairs include ``pair?'', ``cons'', ``car'' and ``cdr''. A pair is a collection of two objects. If the 2nd item in a pair is a list, then the pair is referred to as a list.

Pairs are constructed using the ``cons'' primitive which increases the heap pointer twice and copies the elements of the pair into the new cells which have been allocated. A list constructed using pairs is equivalent to a linked list. The ``car'' and ``cdr'' primitives return the first and second elements.

\begin{table}[ht]
  \centering
\begin{tabular}{ l l }
  \toprule
  Primcall & Description \\ \hline
  \midrule
  (pair? p) & Returns true if p is a Pair.   \\
  (cons a b) & Constructs (a . b)  \\
  (car '(a . b)) & Returns a \\
  (cdr '(a . b)) & Returns b \\
  \bottomrule
\end{tabular}
\caption{Primitives related to Pairs.} \label{tab:pairs}
\end{table}

\begin{verbatim}
;; Construct an improper list

>  (cons 3 (cons 4 5))

>> (3 4 . 5)
\end{verbatim}

In memory, pairs are organised as the following. 

\begin{verbatim}

0 [val 1]
1 [val 2]

\end{verbatim}

The following example shows the code emitted. The construction of pairs and accessing elements on the heap are performed through the use of functions in the C Runtime.

\begingroup
    \fontsize{8pt}{5pt}\selectfont
\begin{verbatim}
>(let* ([p (cons 3 4)]
        [x (car p)]
        [y (cdr p)])
        (mul x y))

define i64 @scheme_entry()
{
entry: 
%tmp = alloca i64

// var11 = 3
store i64 12, i64* %tmp
%var11 = load i64, i64* %tmp     

// var12 = 4
store i64 16, i64* %tmp
%var12 = load i64, i64* %tmp

// Call C Function hptr_con(var11, var12) to construct Pair
%var13 = call i64 @hptr_con(i64 %var11, i64 %var12) 

// Store pair in var10
store i64 %var13, i64* %tmp
%var10 = load i64, i64* %tmp

// Load pair into var16
store i64 %var10, i64* %tmp
%var16 = load i64, i64* %tmp

// Call C function hptr_car(var16) to retrieve Car of Pair
%var17 = call i64 @hptr_car(i64 %var16)
store i64 %var17, i64* %tmp

// Store Car of Pair in var15
%var15 = load i64, i64* %tmp

// Load pair into var19
store i64 %var10, i64* %tmp
%var19 = load i64, i64* %tmp

// Call C function hptr_cdr(var16) to retrieve Cdr of Pair
%var20 = call i64 @hptr_cdr(i64 %var19)
store i64 %var20, i64* %tmp

// Store Cdr of Pair in var18
%var18 = load i64, i64* %tmp

// Load Car
store i64 %var18, i64* %tmp
%var21 = load i64, i64* %tmp

// Load Cdr
store i64 %var15, i64* %tmp
%var22 = load i64, i64* %tmp

// Multiply Car * Cdr 
%var23 = mul  i64 %var22, %var21
%var24 = sdiv i64 %var23,   4
store i64 %var24, i64* %tmp

// Return result
%ret = load i64, i64* %tmp
ret i64 %ret
}
\end{verbatim}
\endgroup

\subsection{Vectors}

The primitives required for the construction of pairs include ``vector?'', ``make-vector'', ``vector-ref'' and ``vector-set!''. 

\begin{table}[ht]
  \centering
\begin{tabular}{ l l }
  \toprule
  Primcall & Description \\ \hline
  \midrule
  (vector? vec) & Returns true if vec is a Vector.. \\
  (make-vector len val) & Constructs \#(val, val, ..) of size len. \\
  (vector-ref vec ind) & Accesses vec[ind] \\
  (vector-set! vec ind val) & Sets vec[ind] = val. \\
  \bottomrule
\end{tabular}
\caption{Primitives related to Pairs.} \label{tab:vectors}
\end{table}

\begin{verbatim}
;; Produce a Vector of size 3 populated with character A.

>  (make-vector 3 #\A) 

>> #(#\A #\A #\A)
\end{verbatim}


\begin{verbatim}

0 [vec len]
1 [val 1]
2 [val 2]
  .
  .

\end{verbatim}

\subsection{Closures}

A closure represents a closed lambda expression and is constructed during the closure conversion code transformation step. It is an Object that is also constructed on the heap. A closure stores the function pointer followed by the values of the free variables.

\begin{verbatim}

0 [fcn ptr]
1 [free v1]
2 [free v2]
  .
  .

\end{verbatim}

\subsection{Strings}

Strings are stored in the same manner as vectors, the string's length is stored. This is followed by the characters which are stored sequentially after. 

\begin{verbatim}
>  (make-string 5 #\A)
>> "AAAAA"

\end{verbatim}

\begin{verbatim}

0 [str len]
1 [val 1]
2 [val 2]
  .
  .

\end{verbatim}





\section{Assignment}

Variables in scheme can be mutated by the use of the ``set!'' procedure.  

\begin{table}[ht]
  \centering
\begin{tabular}{ l l }
  \toprule
  Primcall & Description \\ \hline
  \midrule
  (set! var val) & Assigns var val.  \\
  \bottomrule
\end{tabular}
\caption{Primitives related to Assignment.} \label{tab:assignment}
\end{table}

\subsection{Code Transformation}

Assignment is implemented as a code transformation.

The following example illustrates the challenges of assignment.

\begin{verbatim}
(let ((f (lambda (c) ()
     	 (cons (lambda (v) (c) (set! c v))
	       	       (lambda () (c) c)))))
(let ((p (funcall f 0)))  // Call f (0) to retrieve Pair and set C to 0
     (funcall (car p) 12) // Call ((Car p) 12) to set C to 12
     (funcall (cdr p))))  // Call ((Cdr p)) to retrieve C

\end{verbatim}

The example consists of an outer lambda ``f(c)'' which returns a Pair of lambdas.

The former mutates c and the latter which returns c.

The lambdas are executed in the following order. First, c is set to 0. It is then mutated to 12 and finally the value is returned.

The first challenge is that the variable C is a local variable, so it is ``stack allocated''. However, the variable can outlive the lambda it was declared in. Secondly, the value of c must be mutable such that its mutated value is visible to those who hold a reference to it.

These two challenges can be tackled through the use of a code transformation. It is important to note that variables are defined in a let or a lambda. The code tranformation works firstly by performing a depth first search to find the assignable variables, variables that have the ``set!'' procedure called on them.

Once assignable variables are found, code transformation can be performed. The general idea is to replace the body of a lambda or let where the assignable variable is defined by a let which copies the value of the variable into a vector of size 1. An alternate name for this transformation is ``Boxing''.

Any references made to that variable are done through the vector version of the variable. Assignment via \textbf{set!} is replaced by \textbf{vector-set!}. Variable access is replaced by \textbf{vector-ref}.

\begin{verbatim}

After code transformation. 

(let ((f (lambda (c) ()
     (let ((c (make-vector 1 c)))
     	  (cons (lambda (v) (c) (vector-set! c 0 v))
	  	  (lambda () (c) (vector-ref c 0)))))))
(let ((p (f 0)))
     ((car p) 12)
     ((cdr p))))
\end{verbatim}

The indirection allows each closure to observe the same version of the variable. 

\begin{thebibliography}{5}

\bibitem{wiki} 
Wikipedia
\\\texttt{https://wikipedia.org}

\bibitem{inc}
An Incremental Approach to Compiler Construction.
\\\texttt{http://scheme2006.cs.uchicago.edu/11-ghuloum.pdf}

\bibitem{namin}
A similar project based on the paper, but targets x86.
\\\texttt{https://github.com/namin/inc}

\bibitem{tutorial}
An extended tutorial 
\\\texttt{http://www.cs.indiana.edu/~aghuloum/compilers-tutorial-2006-09-16.pdf}

\bibitem{closure-conversion}
Closure Conversion
\\\texttt{http://matt.might.net/articles/closure-conversion/}

\bibitem{closure-conversion}
Closure Conversion
\\\texttt{http://matt.might.net/articles/closure-conversion/}

\end{thebibliography}  

\end{document}

