\documentclass{article}

\title{SH Project - A Scheme Compiler}
\date{14/01/2018}
\author{150008859}

\setlength{\parskip}{1em}
\setlength{\parindent}{0em}

\usepackage{listings}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{mathtools}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage{booktabs}

\begin{document}
\maketitle
\newpage

\section{Introduction}

The aim of this SH Project was to implement a compiler for a subset of Scheme detailed in the paper ``An incremental approach to Compiler Construction'', in which the author briefly describes its components across 24 sections. The compiler is written in Scheme coupled with a runtime in C.

Originally, the paper targets x86, but my project targets llvm IR instead. This allows me take a more modern approach as the paper is dated from 2006, to take advantage of many of the features that are bundled with llvm including its optimiser and it's ability to compile into many other architectures. 

\section{Project Layout}

The project is organised across many files.

\begin{verbatim}
 - scheme.scm       - The Scheme compiler.
 - runtime.c        - The complimentary runtime.
 - run.scm          - Reading file contents and running compiler.
 - test_driver.scm  - The testing framework.
 - Makefile         - A Makefile to drive compilation and tests. 
\end{verbatim}

% Talk about the runtime, the scheme_entry function and the emition of llvm and linking the object files


\section{Test Framework}

Due to the incremental nature of the project, the first task was to construct a test framework. This involved implement a procedure ``test'' which accepts a symbolic expression, compiles the s-expression into an executable binary and compares the result produced by the binary with the expected answer.

This allowed implementing a feature and immediately being able to verify the computation.

% Explain how it works, e.g. makefile and new directory.



\section{Immediate Values}

This section discusses the task of implementing immediate values which constitute of integers, characters, booleans and the empty list. It also gives an insight at the code emitted by the compiler. During the compilation process, immediates are packed into a ``value and tag form'' and returned.

Table~\ref{tab:immediates} shows the masks, tags and sizes of the packed immediates. For example, the value 42 is shifted left twice to produce the packed value 168. 

\begin{table}[ht]
  \centering
\begin{tabular}{ l c c c }
  \toprule
  Type & Mask & Tag & Size \\ \hline
  \midrule
  Integer & 0x03 & 0x00 & 30 bits  \\
  Character & 0xFF & 0x0F & 24 bits  \\
  Boolean & 0x7F & 0x1F & 1 bit \\
  Empty List & 0xFF & 0x2F & 0 bits \\
  \bottomrule
\end{tabular}
\caption{Masks, tags and sizes of immediate values.} \label{tab:immediates}
\end{table}

The following example demonstrates how the immediate value ``42'' is compiled. 

\begin{verbatim}
>42

 define i64 @scheme_entry()   /* Header 
 {                            
   entry:
   %tmp = alloca i64              ..  */

   store i64 168, i64* %tmp   /* Body */ 

   %ret = load i64, i64* %tmp /* Footer
   ret i64 %ret                   
 }                                ..  */
\end{verbatim}

As there are no registers or an operand stack in llvm, a variable representing a memory location named ``tmp'' is designated as the return value holder similar to how the ``eax'' register holds the return address in the cdecl calling convention. The variable is allocated in the header. At the end of the program, the value stored in tmp is returned. In the runtime, the ``scheme\_entry'' function is called and displays the value returned. 

To supplement the immediate values, the runtime was extended to display the immediate value returned by the program. 

\section{Primitives}

The compiler was then extended by adding unary primitives. Unary primitives are procedures which are natively defined in the environment and accept a single argument. Arguments are emitted first and the result stored in temporary variables. 

\begin{verbatim}
>(add1 42)

 define i64 @scheme_entry()     /* Header
 {
   entry:
   %tmp = alloca i64                    .. */
   store i64 168, i64* %tmp     /* Emit 42 */ 
   %var10 = load i64, i64* %tmp 
   %var11 = add i64 %var10, 4   /* Add   1 */
   store i64 %var11, i64* %tmp  
   %ret = load i64, i64* %tmp   /* Footer 
   ret i64 %ret                         .. */
 }
\end{verbatim}

These unary primitives can be combined to form some semblance of a program.

\begin{verbatim}
>(add1 (sub1 42))

 define i64 @scheme_entry()
 {
   entry: 
   %tmp = alloca i64
   store i64 168, i64* %tmp
   %var12 = load i64, i64* %tmp
   %var13 = sub i64 %var12, 4
   store i64 %var13, i64* %tmp
   %var10 = load i64, i64* %tmp
   %var11 = add i64 %var10, 4
   store i64 %var11, i64* %tmp
   %ret = load i64, i64* %tmp
   ret i64 %ret
 }
\end{verbatim}


\section{Let and the Local Variables}

\section{Conditionals}

\section{Lambdas}

\subsection{Code Transformation}

\section{Datastructures and the Heap}

Pairs, Vectors, Closures and Strings are datastructures that cannot be represented by a single fixed width number. Hence, the runtime was extended by adding a heap. A contigious region of memory is allocated to store runtime objects that cannot be represented by an immediate.

The objects are constructed on the heap and a pointer to them is emitted. By aligning the allocated objects to a multiple of 8, the last 3 bits of a pointer can be used to store a tag, these can be found in Table~\ref{tab:datastructures}.

\begin{table}[ht]
  \centering
\begin{tabular}{ l c c }
  \toprule
  Type & Mask & Tag  \\ \hline
  \midrule
  Pairs  & 0x07 & 0x01 \\
  Closures & 0x07 & 0x02 \\
  Vectors & 0x07 & 0x05 \\
  Strings & 0x07 & 0x06 \\
  \bottomrule
\end{tabular}
\caption{Masks and Tags of datastructures.} \label{tab:datastructures}
\end{table}

\subsection{Pairs}

The primitives required for the construction of pairs include ``pair?'', ``cons'', ``car'' and ``cdr''. A pair is a collection of two objects. If the 2nd item in a pair is a list, then the pair is referred to as a list.

Pairs are constructed using the ``cons'' primitive which increases the heap pointer twice and copies the elements of the pair into the new cells which have been allocated. A list constructed using pairs is equivalent to a linked list. The ``car'' and ``cdr'' primitives return the first and second elements.

\begin{table}[ht]
  \centering
\begin{tabular}{ l l }
  \toprule
  Primcall & Description \\ \hline
  \midrule
  (pair? p) & Returns true if p is a Pair.   \\
  (cons a b) & Constructs (a . b)  \\
  (car '(a . b)) & Returns a \\
  (cdr '(a . b)) & Returns b \\
  \bottomrule
\end{tabular}
\caption{Primitives related to Pairs.} \label{tab:pairs}
\end{table}

\begin{verbatim}
;; Construct an improper list

>  (cons 3 (cons 4 5))

>> (3 4 . 5)
\end{verbatim}

% TODO Make Diagram
% TODO Show Code Emitted

\subsection{Vectors}

The primitives required for the construction of pairs include ``vector?'', ``make-vector'', ``vector-ref'' and ``vector-set!''.

\begin{table}[ht]
  \centering
\begin{tabular}{ l l }
  \toprule
  Primcall & Description \\ \hline
  \midrule
  (vector? vec) & Returns true if vec is a Vector.. \\
  (make-vector len val) & Constructs \#(val, val, ..) of size len. \\
  (vector-ref vec ind) & Accesses vec[ind] \\
  (vector-set! vec ind val) & Sets vec[ind] = val. \\
  \bottomrule
\end{tabular}
\caption{Primitives related to Pairs.} \label{tab:pairs}
\end{table}

\begin{verbatim}
;; Produce a Vector of size 3 populated with character A.

>  (make-vector 3 #\A) 

>> #(#\A #\A #\A)
\end{verbatim}

\subsection{Closures}

A closure represents a closed lambda expression and is constructed during the closure conversion code transformation step. It is an Object that is also constructed on the heap.

\subsection{Strings}

Strings are represented in the same manner as vectors, the string's length is stored. The characters are stored in the packed form sequentally after.

\begin{verbatim}
>  (make-string 5 #\A)
>> "AAAAA"

\end{verbatim}

\section{Assignment}



\subsection{Code Transformation}



\begin{thebibliography}{5}

\bibitem{wiki} 
Wikipedia
\\\texttt{https://wikipedia.org}

\bibitem{inc}
An Incremental Approach to Compiler Construction.
\\\texttt{http://scheme2006.cs.uchicago.edu/11-ghuloum.pdf}

\bibitem{namin}
A similar project based on the paper, but targets x86.
\\\texttt{https://github.com/namin/inc}

\bibitem{tutorial}
An extended tutorial 
\\\texttt{http://web.archive.org/web/20110310113240/http://www.cs.indiana.edu/~aghuloum/compilers-tutorial-2006-09-16.pdf}

\end{thebibliography}  

\end{document}

